// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package downloader

import (
	"sync"

	"github.com/superboomer/maptile/app/cache"
	"github.com/superboomer/maptile/app/provider"
	"github.com/superboomer/maptile/app/tile"
)

// Ensure, that DownloaderMock does implement Downloader.
// If this is not the case, regenerate this file with moq.
var _ Downloader = &DownloaderMock{}

// DownloaderMock is a mock implementation of Downloader.
//
//	func TestSomethingThatUsesDownloader(t *testing.T) {
//
//		// make and configure a mocked Downloader
//		mockedDownloader := &DownloaderMock{
//			DownloadFunc: func(c cache.Cache, l provider.Provider, tiles ...tile.Tile) ([]tile.Tile, error) {
//				panic("mock out the Download method")
//			},
//			MergeFunc: func(side int, centerTile tile.Tile, tiles ...tile.Tile) ([]byte, error) {
//				panic("mock out the Merge method")
//			},
//		}
//
//		// use mockedDownloader in code that requires Downloader
//		// and then make assertions.
//
//	}
type DownloaderMock struct {
	// DownloadFunc mocks the Download method.
	DownloadFunc func(c cache.Cache, l provider.Provider, tiles ...tile.Tile) ([]tile.Tile, error)

	// MergeFunc mocks the Merge method.
	MergeFunc func(side int, centerTile tile.Tile, tiles ...tile.Tile) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// Download holds details about calls to the Download method.
		Download []struct {
			// C is the c argument value.
			C cache.Cache
			// L is the l argument value.
			L provider.Provider
			// Tiles is the tiles argument value.
			Tiles []tile.Tile
		}
		// Merge holds details about calls to the Merge method.
		Merge []struct {
			// Side is the side argument value.
			Side int
			// CenterTile is the centerTile argument value.
			CenterTile tile.Tile
			// Tiles is the tiles argument value.
			Tiles []tile.Tile
		}
	}
	lockDownload sync.RWMutex
	lockMerge    sync.RWMutex
}

// Download calls DownloadFunc.
func (mock *DownloaderMock) Download(c cache.Cache, l provider.Provider, tiles ...tile.Tile) ([]tile.Tile, error) {
	if mock.DownloadFunc == nil {
		panic("DownloaderMock.DownloadFunc: method is nil but Downloader.Download was just called")
	}
	callInfo := struct {
		C     cache.Cache
		L     provider.Provider
		Tiles []tile.Tile
	}{
		C:     c,
		L:     l,
		Tiles: tiles,
	}
	mock.lockDownload.Lock()
	mock.calls.Download = append(mock.calls.Download, callInfo)
	mock.lockDownload.Unlock()
	return mock.DownloadFunc(c, l, tiles...)
}

// DownloadCalls gets all the calls that were made to Download.
// Check the length with:
//
//	len(mockedDownloader.DownloadCalls())
func (mock *DownloaderMock) DownloadCalls() []struct {
	C     cache.Cache
	L     provider.Provider
	Tiles []tile.Tile
} {
	var calls []struct {
		C     cache.Cache
		L     provider.Provider
		Tiles []tile.Tile
	}
	mock.lockDownload.RLock()
	calls = mock.calls.Download
	mock.lockDownload.RUnlock()
	return calls
}

// Merge calls MergeFunc.
func (mock *DownloaderMock) Merge(side int, centerTile tile.Tile, tiles ...tile.Tile) ([]byte, error) {
	if mock.MergeFunc == nil {
		panic("DownloaderMock.MergeFunc: method is nil but Downloader.Merge was just called")
	}
	callInfo := struct {
		Side       int
		CenterTile tile.Tile
		Tiles      []tile.Tile
	}{
		Side:       side,
		CenterTile: centerTile,
		Tiles:      tiles,
	}
	mock.lockMerge.Lock()
	mock.calls.Merge = append(mock.calls.Merge, callInfo)
	mock.lockMerge.Unlock()
	return mock.MergeFunc(side, centerTile, tiles...)
}

// MergeCalls gets all the calls that were made to Merge.
// Check the length with:
//
//	len(mockedDownloader.MergeCalls())
func (mock *DownloaderMock) MergeCalls() []struct {
	Side       int
	CenterTile tile.Tile
	Tiles      []tile.Tile
} {
	var calls []struct {
		Side       int
		CenterTile tile.Tile
		Tiles      []tile.Tile
	}
	mock.lockMerge.RLock()
	calls = mock.calls.Merge
	mock.lockMerge.RUnlock()
	return calls
}
